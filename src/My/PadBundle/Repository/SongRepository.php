<?php

namespace My\PadBundle\Repository;

use Doctrine\ORM\EntityRepository;

/**
 * SongRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class SongRepository extends EntityRepository
{
	/** Return table size */
	public function getSize($int = false)
	{
		$qb = $this->getEntityManager()->createQueryBuilder();
		$played = $qb->select($qb->expr()->count('s.id'))->from('My\PadBundle\Entity\Song', 's')
			->where('s.playcount > 0')
			->getQuery()
			->getSingleScalarResult();

		$qb = $this->getEntityManager()->createQueryBuilder();
		$unplayed = $qb->select($qb->expr()->count('s.id'))->from('My\PadBundle\Entity\Song', 's')
			->where('s.playcount < 1')
			->getQuery()
			->getSingleScalarResult();

		if ($int) return ($unplayed + $played);
		elseif ($unplayed > 0) return $played . '+' . $unplayed;
		else return $played;
	}


	/** Return max playcount */
	public function getMaxPlaycount()
	{
		$qb = $this->getEntityManager()->createQueryBuilder();
		$maxPlaycount = $qb->select($qb->expr()->max('s.playcount'))->from('My\PadBundle\Entity\Song', 's')
			->getQuery()
			->getSingleScalarResult();
		if ($maxPlaycount === 0) $maxPlaycount = 1;
		return $maxPlaycount;
	}


	/**
	 * Count unplayed
	 */
	public function countUnplayed()
	{
		$qb = $this->getEntityManager()->createQueryBuilder();
		return $qb->select($qb->expr()->count('s.id'))->from('MyPadBundle:Song', 's')
			->where('s.playcount = ?1')->setParameter(1, 0)
			->getQuery()
			->getSingleScalarResult();
	}


	/** Gets Ladder */
	public function getLadder($side, $limit=10)
	{
		if ($side == 'top') $order = 'desc';
		elseif ($side == 'low') $order = 'asc';
		else throw new \Exception('unknown side: ' . $side);

		$qb = $this->getEntityManager()->createQueryBuilder();
		return $qb->select('s')->from('My\PadBundle\Entity\Song', 's')
			->where('s.title IS NOT NULL')
			->andWhere('s.rating IS NOT NULL')
			->orderBy('s.rating', $order)
			->addOrderBy('s.rated', 'desc')
			->addOrderBy('s.playcount', 'desc')
			->setMaxResults($limit)
			->getQuery()
			->getResult();
	}


	/**
	 * Gets average date of songs being played at
	 */
	public function getAveragePlayedAt()
	{
		$rsm = new \Doctrine\ORM\Query\ResultSetMapping();
		$rsm->addScalarResult('avg_played', 'avg_played');
		$query = $this->getEntityManager()->createNativeQuery('select avg(unix_timestamp(playedAt)) as avg_played from songs', $rsm);
		$timestamp = $query->getSingleScalarResult();
		return new \Datetime(date('Y-m-d H:i:s', round($timestamp)));
	}


	/** Clean table */
	public function clean()
	{
		$removed = 0;
		$songs = $this->findAll();
		if (count($songs)) foreach ($songs as $song) {
			if (!file_exists(AUDIO_PATH . '/' . $song->getPath())) {
				$this->getEntityManager()->remove($song);
				$removed++;
			}
		}
		return $removed;
	}


	/** Add new */
	public function add($pathInfo)
	{
		//die(var_dump($pathInfo));
		$path = implode('/', array($pathInfo['dirname'], $pathInfo['basename']));
		$songExists = $this->findOneByPath($path);
		if ($songExists) return false;

		$em = $this->getEntityManager();
		$song = new \My\PadBundle\Entity\Song();
		$em->persist($song);
		$song->setPath($path);
		$song->setCodec(strtolower($pathInfo['extension']));

		return $song;
	}


	/** Scan */
	public function scan($dir)
	{
		static $added = 0;
    	if (is_null($dir)) $dir = AUDIO_PATH;
    	//die(var_dump($dir));

		$files = scandir($dir);
		//die(var_dump($files));

		// delete empty directories
		if (count($files) < 3 && $dir != AUDIO_PATH) rmdir($dir);
		else foreach ($files as $file) {
			if ($file == '.' || $file == '..') continue;

			// recurse dir
			if (is_dir($dir . '/' . $file)) {
				$this->scan($dir . '/' . $file);
			}

			else {
				$pathInfo = pathinfo($dir . '/' . $file);
				if (strpos($pathInfo['dirname'], AUDIO_PATH) !== false) $pathInfo['dirname'] = str_replace(AUDIO_PATH, '', $pathInfo['dirname']);
				else throw new \Exception('Not in audio directory');
				// remove / in root dir
				if (strpos($pathInfo['dirname'], '/') === 0) $pathInfo['dirname'] = substr($pathInfo['dirname'], 1);
				//die(var_dump($pathInfo));

				if (in_array(strtolower($pathInfo['extension']), array('mp3', 'wav', 'm4a'))) {
					$song = $this->add($pathInfo);
					if ($song) $added++;

				} else {
					// remove non-music (mp3/wav) files
					unlink($dir . '/' . $file);
					//die($file . ' is not an audio file');
				}
			}
		}

		return $added;
	}


	/** Add songs to playlist */
	public function fillPlaylist($playlist, $history)
	{
		// first play unplayed songs
		$qb = $this->getEntityManager()->createQueryBuilder();
		$unplayed = $qb->select('s')->from('\My\PadBundle\Entity\Song', 's')
			->where('s.playcount = 0')
			->orWhere('s.title IS NULL')
			->orWhere('s.artist IS NULL')
			->setMaxResults(999)
			->getQuery()
			->getResult();
		if ($unplayed) {
			$song = $unplayed[rand(0, count($unplayed)-1)];
			return array($song->getId() => $song->getPriority());
		}

		// add songs randomly to playlist till it's a reasonable size
		// must not already be in history or in playlist
		// save with highest priority
		$librarySize = $this->getSize(true);
		if ($librarySize < 1) die('No songs');
		$playlistSize = $librarySize * 0.33;

		$playlistQuicken = $playlistSize * 0.25;
		for ($i=0; $i<$playlistQuicken; $i++) {
			if (!count($playlist)) break;
			array_pop($playlist);
		}

		while (count($playlist) < $playlistSize) {
			$qb = $this->getEntityManager()->createQueryBuilder();
			$song = $qb->select('s')->from('\My\PadBundle\Entity\Song', 's')
				->setFirstResult(rand(0, ($librarySize - 1)))
				->setMaxResults(1)
				->getQuery()
				->getSingleResult();
			if (!in_array($song->getId(), $history) && !array_key_exists($song->getId(), $playlist)) $playlist[$song->getId()] = $song->getPriority();
		}

		// just return first one (highest priority)
		arsort($playlist);
		return $playlist;
	}


	/**
	 * Get worst song
	 */
	public function findWorstSong($offset = null, $noAlbum = false)
	{
		if (is_null($offset)) $offset = 0;

		$qb = $this->getEntityManager()->createQueryBuilder();
		$qb->select('s')->from('\My\PadBundle\Entity\Song', 's')
			->where('s.playcount > 0')
			->andWhere('s.rated >= 9');
		if ($noAlbum) $qb->andWhere('s.album IS NULL');
		return $qb->orderBy('s.rating', 'asc')
			->addOrderBy('s.playcount', 'desc')
			->setFirstResult($offset)
			->setMaxResults(1)
			->getQuery()
			->getSingleResult();
	}


	/**
	 * Get best song
	 */
	public function findBestSong($offset = null, $noAlbum = false)
	{
		if (is_null($offset)) $offset = 0;

		$qb = $this->getEntityManager()->createQueryBuilder();
		$qb->select('s')->from('\My\PadBundle\Entity\Song', 's')
			->where('s.playcount > 0')
			->andWhere('s.rated >= 9');
		if ($noAlbum) $qb->andWhere('s.album IS NULL');
		return $qb->orderBy('s.rating', 'DESC')
			->addOrderBy('s.playcount', 'DESC')
			->setFirstResult($offset)
			->setMaxResults(1)
			->getQuery()
			->getSingleResult();
	}


	/**
	 * Get Last Played At
	 */
	public function getLastPlayedAt()
	{
		$qb = $this->getEntityManager()->createQueryBuilder();
		return $qb->select('s.playedAt')->from('\My\PadBundle\Entity\Song', 's')
			->where('s.playedAt IS NOT NULL')
			->orderBy('s.playedAt', 'DESC')
			->setMaxResults(1)
			->getQuery()
			->getSingleResult();
	}


	/**
	 * Get TOP
	 */
	public function getTop()
	{
		$qb = $this->getEntityManager()->createQueryBuilder();
		return $qb->select('s')->from('\My\PadBundle\Entity\Song', 's')
			->where('s.rating >= 0.90')
			->getQuery()
			->getResult();
	}


	/**
	 * Get Random Song prioritised
	 */
	public function getRandomPrioritised()
	{
		$playedAtAvg = $this->getAveragePlayedAt();
		$countSongs = $this->getSize(true);
		if (!$countSongs) return null;
		$decrement = 2 / $countSongs;

		$priorityCutoff = 1;
		do {
			$priorityCutoff -= $decrement;
			$playedAtAvg->modify('+1 minute');
			$qb = $this->getEntityManager()->createQueryBuilder();
			$song = $qb->select('s')->from('MyPadBundle:Song', 's')
				->setFirstResult(rand(0, ($countSongs - 1)))
				->setMaxResults(1)
				->getQuery()
				->getSingleResult();
		} while ($song->getPriority() < $priorityCutoff || $song->getPlayedAt() > $playedAtAvg);
		//die(var_dump($priorityCutoff));
		//die('song : ' . $song->getPriority());

		return $song;
	}


	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// TIP
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	/**
	 * TIP
	 * Find song that is not in an album
	 */
	public function getSongNotInAlbum()
	{
		$qb = $this->getEntityManager()->createQueryBuilder();
		$songs = $qb->select('s')->from('MyPadBundle:Song', 's')
			->where('s.album IS NULL')
			->orderBy('s.modifiedAt', 'DESC')
			->setMaxResults(1)
			->getQuery()
			->getResult();
		if (!$songs) return;

		$song = $songs[0];
		return array(
			'tip' => 'No <a id="' . $song->getId() . '" class="statAlbum" href="#album">album</a> for worst song: <a href="http://en.wikipedia.org/wiki/Special:Search/' . str_replace(' ', '_', $song->getTitle()) . '" target="_newtab">' . (!is_null($song->getArtist()) ? $song->getArtist()->getName() . ' - ' : '') . $song->getTitle() . '</a>',
			'entityId'=> $song->getId(),
		);
	}


	/**
	 * Gets average rating count
	 */
	public function getAverageRatedAt()
	{
		$rsm = new \Doctrine\ORM\Query\ResultSetMapping();
		$rsm->addScalarResult('avg_rated', 'avg_rated');
		$query = $this->getEntityManager()->createNativeQuery('select avg(unix_timestamp(ratedAt)) as avg_rated from songs', $rsm);
		$timestamp = $query->getSingleScalarResult();
		return new \Datetime(date('Y-m-d H:i:s', round($timestamp)));
	}


	/**
	 * Get Average Rated Count of all songs
	 */
	public function getAverageRatedCount()
	{
		$qb = $this->getEntityManager()->createQueryBuilder();
		$avgRated = $qb->select('AVG(s.rated)')->from('MyPadBundle:Song', 's')
			->getQuery()
			->getSingleScalarResult();

		return $avgRated;
	}
}
