<?php

namespace My\PadBundle\Repository;

use Doctrine\ORM\EntityRepository;
use My\PadBundle\Entity\Song;

/**
 * RatingRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class RatingRepository extends EntityRepository
{
	/** Has Competed */
	public function hasCompeted($song1, $song2)
	{
		$qb = $this->getEntityManager()->createQueryBuilder();
		$result = $qb->select('r')->from('My\PadBundle\Entity\Rating', 'r')
			->where('r.winner = ?1')->setParameter(1, $song1->getId())
			->andWhere('r.loser = ?2')->setParameter(2, $song2->getId())
			->getQuery()
			->getResult();
		if (count($result) === 1) return true;

		$qb = $this->getEntityManager()->createQueryBuilder();
		$result = $qb->select('r')->from('My\PadBundle\Entity\Rating', 'r')
			->where('r.winner = ?1')->setParameter(1, $song2->getId())
			->andWhere('r.loser = ?2')->setParameter(2, $song1->getId())
			->getQuery()
			->getResult();
		if (count($result) === 1) return true;

		return false;
	}


	/** Retrieves Songs to Rate */
	public function getSongsToRate($current)
	{
        $timeStart = time();

		if ($current->getRated() >= max(5, $current->getPlaycount() * 3)) return null;
		$countSongs = $this->getEntityManager()->getRepository('MyPadBundle:Song')->getSize(true);

		//$avgRated = $this->getEntityManager()->getRepository('MyPadBundle:Song')->getHighestRated();
        $highestRatedSong = $this->getEntityManager()->getRepository('MyPadBundle:Song')->getHighestRated();
        $highestRated = max(1, $highestRatedSong->getRated());
        //die(var_dump($highestRated));
        $ratedDecrement = $highestRated / $countSongs;

		//$avgRatedAt = $this->getEntityManager()->getRepository('MyPadBundle:Song')->getAverageRatedAt();
		$lastRatedAtSong = $this->getEntityManager()->getRepository('MyPadBundle:Song')->getLastRatedAt();
        $lastRatedAt = $lastRatedAtSong->getRatedAt();
        //die(var_dump($lastRatedAt));
        $diff = time() - $lastRatedAt->getTimestamp();
        $timeIncrement = max(1, $diff / $countSongs);

        $enchanced = 50;
//		$failCount = 0;
		do {
//			$failCount++;
//			if ($failCount > $countSongs * $enchanced) {
//                return null;
//            }

			$lastRatedAt->modify('+' . round($timeIncrement) * $enchanced . ' seconds');
			$highestRated -= $ratedDecrement * $enchanced;

			$qb = $this->getEntityManager()->createQueryBuilder();
			$song = $qb->select('s')->from('MyPadBundle:Song', 's')
				->setFirstResult(rand(0, ($countSongs - 1)))
				->setMaxResults(1)
				->getQuery()
				->getSingleResult();

            if (time() - $timeStart > 2) {
                break;
            }

		} while ($song->getId() == $current->getId() or
			$song->getPlaycount() < 1 or
			is_null($song->getTitle()) or
			is_null($song->getArtist()) or
			$song->getRatedAt() > $lastRatedAt or
			$song->getRated() > $highestRated
			//$this->hasCompeted($current, $song)
		);

		return $song;
	}

	/**
     * Get song to rate
     * Retrieves a song that was rated long ago
     */
	public function getSongToRate(Song $current)
	{
        set_time_limit(5);

        /** @var SongRepository $songRepo */
        $songRepo = $this->getEntityManager()->getRepository('MyPadBundle:Song');

		if ($current->getRated() >= max(5, $current->getPlaycount() * 3)) {
            return null;
        }

		$countSongs = $songRepo->getSize(true);
        if ($countSongs < 2) {
            return null;
        }

        $highestRatedSong = $songRepo->getHighestRated();
        $highestRated = max(1, $highestRatedSong->getRated());
        $ratedDecrement = $highestRated / $countSongs;

		$lastRatedAtSong = $songRepo->getLastRatedAt();
        $lastRatedAt = $lastRatedAtSong->getRatedAt();
        $diff = time() - $lastRatedAt->getTimestamp();
        $timeIncrement = max(1, $diff / $countSongs);

        $ratedCutOff = $highestRated * 0.25;
        $lastRatedAt->modify('+' . round($diff * 0.75) . ' seconds');
		do {
			$lastRatedAt->modify('+' . round($timeIncrement) . ' seconds');
			$ratedCutOff += $ratedDecrement;

            $query = $this->getEntityManager()->createQuery("
                    SELECT s
                    FROM MyPadBundle:Song s
                    WHERE s.id <> :id
                    AND s.playcount >= :playcount
                    AND s.title IS NOT NULL
                    AND s.artist IS NOT NULL
                    AND s.ratedAt < :ratedAt
                    AND s.rated < :rated
                    ORDER BY s.playcount DESC
                ")
                ->setMaxResults(1)
                ->setParameters(array(
                    'id' => $current->getId(),
                    'playcount' => 1,
                    'ratedAt' => $lastRatedAt->format('Y-m-d H:i:s'),
                    'rated' => $ratedCutOff
                ));
            $song = $query->getOneOrNullResult();
            if (is_null($song)) {
                $songInfo = 'no song found';
            } else {
                $songInfo = 'song ' . $song->getId() . ' ' . $song->getRatedAt()->format('Y-m-d H:i:s') . ' ' . $song->getRated();
            }
            $log[] = $lastRatedAt->format('Y-m-d H:i') . ' ' . round($ratedCutOff) . ': ' . $songInfo;
		} while (is_null($song));

        //die(var_dump($log));
		return $song;
	}

	/** Clean table */
	public function clean()
	{
		$qb = $this->getEntityManager()->createQueryBuilder();
		return $qb->delete('My\PadBundle\Entity\Rating', 'r')
			->where('r.winner IS NULL')
			->orWhere('r.loser IS NULL')
			->getQuery()
			->getResult();
	}
}
